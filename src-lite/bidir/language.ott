metavar bexprvar, x, y, z ::= {{ repr-locally-nameless }}
metavar number, n ::= {{ coq nat }}

grammar

bkind, k :: 'bk_' ::= {{ com kind }}
  | *   :: :: star {{ com type of type }}
  | box :: :: box  {{ com type of type of type }}

bbody, b :: 'bb_' ::= {{ com annotated function body }}
  | e : A :: :: anno

bexpr, e, A, B, C, D, t, s :: 'be_' ::= {{ com expressions }}
  | x     :: :: var  {{ com variable }}
  | k     :: :: kind {{ com type of type }}
  | n     :: :: num  {{ com integer value }}
  | int   :: :: int  {{ com integer type }}
  | bot : A :: :: bot  {{ com bottom value }}
  | e1 e2   :: :: app  {{ com application }}
  | lambda x : A . b :: :: abs  (+ bind x in b +) {{ com abstraction }}
  | pi     x : A . B :: :: pi   (+ bind x in B +) {{ com dependent product }}
  | bind   x : A . b :: :: bind (+ bind x in b +) {{ com implicit lambda }}
  | forall x : A . B :: :: all  (+ bind x in B +) {{ com implicit function type }}
%  | mu     x : A . e :: :: mu   (+ bind x in e +) {{ com fix point expression }}
  | castup [ A ] e :: :: castup {{ com cast up }}
  | castdn       e :: :: castdn {{ com cast down }}
  | e : A :: :: anno {{ com annotation }}
  | ( e )         :: S :: paren {{ coq ([[e]]) }}
  | [ e1 / x ] e2 :: M :: subst {{ coq (open_bexpr_wrt_bexpr [[x e2]] [[e1]]) }}

bcontext, G :: 'bctx_' ::=
  | nil       :: :: nil
  | G , x : A :: :: cons

dir, d :: 'd_' ::=
  | => :: :: infer
  | <= :: :: check

obindd, ob :: 'dob_' ::=
  | none   :: :: none
  | x _: A :: :: bind

dcont, c :: 'dc_' ::=
  | Done       :: :: done
  | _ . e => c :: :: iapp
  | _ --> c    :: :: reduce
  | _ <: A , c :: :: inst
  | _ <~: A    :: :: check

dwork, w :: 'dw_' ::=
  | ob |= e1 <: e2 <= A :: :: check
  | e1 <: e2 => c :: :: infer
  | A =>> c :: :: infer_app
  | e --> c :: :: reduce
  | A <~: B :: :: compact
  | c $ e   :: :: apply

dworklist, wl :: 'dwl_' ::=
  | wnil         :: :: nil
  | wl |- w      :: :: cons
  | wl ,' x :' A :: :: bind

app_fun, F :: 'fun_' ::=
  | Pi x : A . B :: :: pi (+ bind x in B +)

formula :: formula_ ::=
  | judgement  ::   :: judgement
  | G |- e d A :: M :: bi_typing {{ coq (busub [[G]] [[e]] [[e]] [[d]] [[A]]) }}
  | x # G      :: M :: ctx_fresh {{ coq ([[x]] `notin` bctx_dom [[G]]) }}
  | x # e *    :: M :: erased_fresh
    {{ coq ([[x]] `notin` fv_eexpr (berase [[e]])) }}
  | A = B :: M :: equality {{ coq [[A]] = [[B]] }}

substitutions
  single e x :: subst

freevars
  bexpr    x :: fv

embed {{ coq

Require Import erased.ott.

Fixpoint bctx_dom (G : bcontext) : atoms :=
  match G with
  | bctx_nil => {}
  | bctx_cons G x A => add x (bctx_dom G)
  end
.

Fixpoint berase (e : bexpr) : eexpr :=
  match e with
  | be_var_f x => ee_var_f x
  | be_var_b x => ee_var_b x
  | be_kind bk_star => ee_kind ek_star
  | be_kind bk_box  => ee_kind ek_box
  | be_num n => ee_num n
  | be_int   => ee_int
  | be_bot A => ee_bot
  | be_app f a => ee_app (berase f) (berase a)
  | be_abs  A (bb_anno e B) => ee_abs  (berase e)
  | be_bind A (bb_anno e B) => ee_bind (berase e)
  | be_pi  A B => ee_pi  (berase A) (berase B)
  | be_all A B => ee_all (berase A) (berase B)
  | be_castup A e => ee_castup (berase e)
  | be_castdn e   => ee_castdn (berase e)
  | be_anno e A => berase e
  end
.
}}

defns
Monotype :: '' ::=

defn
mono A :: :: mono_btype :: 'bmono_'
by

----------- :: kind
mono k

----------- :: var
mono x

------------- :: int
mono int

----------- :: lit
mono n

----------------- :: bot
mono bot : A

mono e1
mono e2
----------------- :: app
mono (e1 e2)

mono A
mono B
---------------------- :: pi
mono pi x : A . B

mono e
-------------------------- :: lambda
mono lambda x : A . e : B

mono e
------------------------ :: bind
mono bind x : A . e : B

% mono e
% ---------------------- :: mu
% mono mu x : A . e

mono e
---------------------- :: castup
mono castup [A] e

mono e
---------------------- :: castdn
mono castdn e

mono e
---------------------- :: anno
mono e : A

defns
Reduce :: '' ::=

defn
e1 --> e2 :: :: breduce :: 'br_' {{ com Reduction in Source Language }}
by

e1 --> e2
---------------- :: app
e1 e3 --> e2 e3

------------------------------------------- :: beta
(lambda x : A . e1 : B) e2 --> [e2 / x] e1

mono e
--------------------------------------------- :: inst
(bind x : A . e1 : B) e2 --> ([e / x] e1) e2

% -------------------------------------- :: mu
% mu x : A. e --> [mu x : A. e / x] e

e1 --> e2
--------------------------- :: castdn
castdn e1 --> castdn e2

mono e
----------------------------------------------------- :: cast_inst
castdn (bind x : A . e1 : B) --> castdn ([e / x] e1)

---------------------------- :: cast_elim
castdn (castup [B] e) --> e

e1 --> e2
------------------ :: anno
e1 : A --> e2 : A

defns
InContext :: '' ::=

defn
x : A in G :: :: in_bctx :: 'inb_'
by

------------------ :: here
x : A in G, x : A

x : A in G
------------------ :: there
x : A in G, y : B

defns
BidirectionalUnifiedSubtyping :: '' ::=

defn
|=> G :: :: wf_bcontext :: 'bwf_'
by

-------- :: nil
|=> nil

|=> G
x # G
G |- A => k
-------------- :: cons
|=> G , x : A

defn
G |- A =>> F :: :: infer_app :: 'iapp_'
by

--------------------------------- :: pi
G |- pi x : A. B =>> Pi x : A. B

mono t
G |- t <= A
G |- [t / x] B =>> F
-------------------------------- :: all
G |- forall x : A. B =>> F

defn
G |- e1 -->> e2 :: :: greduce :: 'gr_'
by

e1 --> e2
---------------- :: reduce
G |- e1 -->> e2

mono t
G |- t <= A
G |- [t / x] B -->> C
---------------------------- :: all
G |- forall x : A. B -->> C


defn
G |- e1 <: e2 d A :: :: busub :: 'bs_' {{ com Unified Subtyping }}
by

|=> G
x : A in G
------------------- :: var
G |- x <: x => A

|=> G
------------------- :: lit
G |- n <: n => int

|=> G
------------------- :: star_inf
G |- * <: * dir box

|=> G
--------------------- :: int
G |- int <: int => *

G |- A1 <: A2 => k
G |- A2 <: A1 => k
--------------------------------- :: bot
G |- bot : A1 <: bot : A2 => A1

G |- A1 <: A2 => k1
G |- A2 <: A1 => k1
G , x : A1 |- B1 <: B2 => k2
G , x : A1 |- B2 <: B1 => k2
G , x : A1 |- e1 <: e2 <= B1
------------------------------------------------------------------------- :: abs
G |- lambda x : A1 . e1 : B1 <: lambda x : A2 . e2 : B2 => pi x : A1. B1

G |- A1 => k1
G |- A2 <: A1 => k1
G , x : A1 |- B1 dir k2
G , x : A2 |- B1 <: B2 dir k2
------------------------------------------- :: pi
G |- pi x : A1. B1 <: pi x : A2. B2 dir k2

mono t
G |- e1 <: e2 => A
G |- A =>> Pi x : B. C
G |- t <= B
-------------------------------- :: app
G |- e1 t <: e2 t => [t / x] C

G |- A1 <: A2 => k
G |- A2 <: A1 => k
G , x : A1 |- B1 <: B2 <= *
G , x : A1 |- B2 <: B1 <= *
G , x : A1 |- e1 <: e2 <= B1
x # e1*
x # e2*
------------------------------------------------------------------------ :: bind
G |- bind x : A1 . e1 : B1 <: bind x : A2. e2 : B2 => forall x : A1. B1

% monotype mu x : t. s
% G |- t : k
% G , x : t |- s : t
% ------------------------------------ :: mu
% G |- mu x : t. s <: mu x : t. s : t

G |- A1 <: A2 => k
G |- A2 <: A1 => k
A1 --> B
A2 --> B
G |- e1 <: e2 <= B
--------------------------------------- :: castup
G |- castup [A1] e1 <: castup [A2] e2 => A1

G |- B => k
G |- A -->> B
G |- e1 <: e2 => A
--------------------------------------- :: castdn
G |- castdn e1 <: castdn e2 => B

mono t
G |- A => k
G |- t <= A
G |- [t/x] B <: C => *
G , x : A |- B => *
------------------------------- :: forall_l
G |- forall x : A. B <: C => *

G |- B => k
G |- A => *
G , x : B |- A <: C => *
------------------------------- :: forall_r
G |- A <: forall x : B. C => *

G |- A1 <: A2 => k
G |- A2 <: A1 => k
G , x : A1 |- B <: C => *
----------------------------------------------- :: forall
G |- forall x : A1. B <: forall x : A2. C => *

G |- e1 <: e2 <= A1
G |- A1 <: A2 => k
G |- A2 <: A1 => k
------------------------------ :: anno
G |- e1 : A1 <: e2 : A2 => A1

G |- e1 <: e2 => A
G |- A  <: B  => k
------------------- :: sub
G |- e1 <: e2 <= B
