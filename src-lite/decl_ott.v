(* generated by Ott 0.31, locally-nameless lngen from: decl.ott *)
Require Import Bool.
Require Import Metalib.Metatheory.
Require Import List.
(** syntax *)
Definition exprvar : Set := var.
Definition number : Set := nat.

Inductive kind : Set :=  (*r kind *)
 | k_star : kind (*r type of type *)
 | k_box : kind (*r type of type of type *).

Inductive body : Set :=  (*r annotated function body *)
 | b_anno (e:expr) (A:expr)
with expr : Set :=  (*r expressions *)
 | e_var_b (_:nat) (*r variable *)
 | e_var_f (x:exprvar) (*r variable *)
 | e_kind (k:kind) (*r type of type *)
 | e_num (n:number) (*r integer value *)
 | e_int : expr (*r integer type *)
 | e_bot (A:expr) (*r bottom value *)
 | e_app (e1:expr) (e2:expr) (*r application *)
 | e_abs (A:expr) (b:body) (*r abstraction *)
 | e_pi (A:expr) (B:expr) (*r dependent product *)
 | e_bind (A:expr) (b:body) (*r implicit lambda *)
 | e_all (A:expr) (B:expr) (*r implicit function type *)
 | e_castup (A:expr) (e:expr) (*r cast up *)
 | e_castdn (e:expr) (*r cast down *).

Inductive obindd : Set := 
 | dob_none : obindd
 | dob_bind (x:exprvar) (A:expr).

Inductive context : Set := 
 | ctx_nil : context
 | ctx_cons (G:context) (x:exprvar) (A:expr).

Inductive dir : Set := 
 | d_infer : dir
 | d_check : dir.

Inductive dwork : Set := 
 | dw_check (ob:obindd) (e1:expr) (e2:expr) (A:expr)
 | dw_infer (e1:expr) (e2:expr) (wl:dworklist)
 | dw_infer_app (A:expr) (e1:expr) (e2:expr) (wl:dworklist)
 | dw_reduce (e:expr) (wl:dworklist)
 | dw_compact (A:expr) (B:expr)
with dworklist : Set := 
 | dwl_nil : dworklist
 | dwl_cons (wl:dworklist) (w:dwork)
 | dwl_bind (wl:dworklist) (x:exprvar) (A:expr).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_expr_wrt_expr_rec (k:nat) (e_5:expr) (e__6:expr) {struct e__6}: expr :=
  match e__6 with
  | (e_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => e_var_b nat
        | inleft (right _) => e_5
        | inright _ => e_var_b (nat - 1)
      end
  | (e_var_f x) => e_var_f x
  | (e_kind k) => e_kind k
  | (e_num n) => e_num n
  | e_int => e_int 
  | (e_bot A) => e_bot (open_expr_wrt_expr_rec k e_5 A)
  | (e_app e1 e2) => e_app (open_expr_wrt_expr_rec k e_5 e1) (open_expr_wrt_expr_rec k e_5 e2)
  | (e_abs A b) => e_abs (open_expr_wrt_expr_rec k e_5 A) (open_body_wrt_expr_rec (S k) e_5 b)
  | (e_pi A B) => e_pi (open_expr_wrt_expr_rec k e_5 A) (open_expr_wrt_expr_rec (S k) e_5 B)
  | (e_bind A b) => e_bind (open_expr_wrt_expr_rec k e_5 A) (open_body_wrt_expr_rec (S k) e_5 b)
  | (e_all A B) => e_all (open_expr_wrt_expr_rec k e_5 A) (open_expr_wrt_expr_rec (S k) e_5 B)
  | (e_castup A e) => e_castup (open_expr_wrt_expr_rec k e_5 A) (open_expr_wrt_expr_rec k e_5 e)
  | (e_castdn e) => e_castdn (open_expr_wrt_expr_rec k e_5 e)
end
with open_body_wrt_expr_rec (k:nat) (e5:expr) (b5:body) : body :=
  match b5 with
  | (b_anno e A) => b_anno (open_expr_wrt_expr_rec k e5 e) (open_expr_wrt_expr_rec k e5 A)
end.

Definition open_obindd_wrt_expr_rec (k:nat) (e5:expr) (ob5:obindd) : obindd :=
  match ob5 with
  | dob_none => dob_none 
  | (dob_bind x A) => dob_bind x (open_expr_wrt_expr_rec k e5 A)
end.

Fixpoint open_dworklist_wrt_expr_rec (k:nat) (e5:expr) (wl5:dworklist) {struct wl5}: dworklist :=
  match wl5 with
  | dwl_nil => dwl_nil 
  | (dwl_cons wl w) => dwl_cons (open_dworklist_wrt_expr_rec k e5 wl) (open_dwork_wrt_expr_rec k e5 w)
  | (dwl_bind wl x A) => dwl_bind (open_dworklist_wrt_expr_rec k e5 wl) x (open_expr_wrt_expr_rec k e5 A)
end
with open_dwork_wrt_expr_rec (k:nat) (e_5:expr) (w5:dwork) : dwork :=
  match w5 with
  | (dw_check ob e1 e2 A) => dw_check (open_obindd_wrt_expr_rec k e_5 ob) (open_expr_wrt_expr_rec k e_5 e1) (open_expr_wrt_expr_rec k e_5 e2) (open_expr_wrt_expr_rec k e_5 A)
  | (dw_infer e1 e2 wl) => dw_infer (open_expr_wrt_expr_rec k e_5 e1) (open_expr_wrt_expr_rec k e_5 e2) (open_dworklist_wrt_expr_rec (S k) e_5 wl)
  | (dw_infer_app A e1 e2 wl) => dw_infer_app (open_expr_wrt_expr_rec k e_5 A) (open_expr_wrt_expr_rec k e_5 e1) (open_expr_wrt_expr_rec k e_5 e2) (open_dworklist_wrt_expr_rec (S k) e_5 wl)
  | (dw_reduce e wl) => dw_reduce (open_expr_wrt_expr_rec k e_5 e) (open_dworklist_wrt_expr_rec (S k) e_5 wl)
  | (dw_compact A B) => dw_compact (open_expr_wrt_expr_rec k e_5 A) (open_expr_wrt_expr_rec k e_5 B)
end.

Fixpoint open_context_wrt_expr_rec (k:nat) (e5:expr) (G5:context) {struct G5}: context :=
  match G5 with
  | ctx_nil => ctx_nil 
  | (ctx_cons G x A) => ctx_cons (open_context_wrt_expr_rec k e5 G) x (open_expr_wrt_expr_rec k e5 A)
end.

Definition open_expr_wrt_expr e_5 e__6 := open_expr_wrt_expr_rec 0 e__6 e_5.

Definition open_obindd_wrt_expr e5 ob5 := open_obindd_wrt_expr_rec 0 ob5 e5.

Definition open_dworklist_wrt_expr e5 wl5 := open_dworklist_wrt_expr_rec 0 wl5 e5.

Definition open_body_wrt_expr e5 b5 := open_body_wrt_expr_rec 0 b5 e5.

Definition open_dwork_wrt_expr e_5 w5 := open_dwork_wrt_expr_rec 0 w5 e_5.

Definition open_context_wrt_expr e5 G5 := open_context_wrt_expr_rec 0 G5 e5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_expr_body *)
Inductive lc_expr : expr -> Prop :=    (* defn lc_expr *)
 | lc_e_var_f : forall (x:exprvar),
     (lc_expr (e_var_f x))
 | lc_e_kind : forall (k:kind),
     (lc_expr (e_kind k))
 | lc_e_num : forall (n:number),
     (lc_expr (e_num n))
 | lc_e_int : 
     (lc_expr e_int)
 | lc_e_bot : forall (A:expr),
     (lc_expr A) ->
     (lc_expr (e_bot A))
 | lc_e_app : forall (e1 e2:expr),
     (lc_expr e1) ->
     (lc_expr e2) ->
     (lc_expr (e_app e1 e2))
 | lc_e_abs : forall (A:expr) (b:body),
     (lc_expr A) ->
      ( forall x , lc_body  ( open_body_wrt_expr b (e_var_f x) )  )  ->
     (lc_expr (e_abs A b))
 | lc_e_pi : forall (A B:expr),
     (lc_expr A) ->
      ( forall x , lc_expr  ( open_expr_wrt_expr B (e_var_f x) )  )  ->
     (lc_expr (e_pi A B))
 | lc_e_bind : forall (A:expr) (b:body),
     (lc_expr A) ->
      ( forall x , lc_body  ( open_body_wrt_expr b (e_var_f x) )  )  ->
     (lc_expr (e_bind A b))
 | lc_e_all : forall (A B:expr),
     (lc_expr A) ->
      ( forall x , lc_expr  ( open_expr_wrt_expr B (e_var_f x) )  )  ->
     (lc_expr (e_all A B))
 | lc_e_castup : forall (A e:expr),
     (lc_expr A) ->
     (lc_expr e) ->
     (lc_expr (e_castup A e))
 | lc_e_castdn : forall (e:expr),
     (lc_expr e) ->
     (lc_expr (e_castdn e))
with lc_body : body -> Prop :=    (* defn lc_body *)
 | lc_b_anno : forall (e A:expr),
     (lc_expr e) ->
     (lc_expr A) ->
     (lc_body (b_anno e A)).

(* defns LC_obindd *)
Inductive lc_obindd : obindd -> Prop :=    (* defn lc_obindd *)
 | lc_dob_none : 
     (lc_obindd dob_none)
 | lc_dob_bind : forall (x:exprvar) (A:expr),
     (lc_expr A) ->
     (lc_obindd (dob_bind x A)).

(* defns LC_context *)
Inductive lc_context : context -> Prop :=    (* defn lc_context *)
 | lc_ctx_nil : 
     (lc_context ctx_nil)
 | lc_ctx_cons : forall (G:context) (x:exprvar) (A:expr),
     (lc_context G) ->
     (lc_expr A) ->
     (lc_context (ctx_cons G x A)).

(* defns LC_dworklist_dwork *)
Inductive lc_dworklist : dworklist -> Prop :=    (* defn lc_dworklist *)
 | lc_dwl_nil : 
     (lc_dworklist dwl_nil)
 | lc_dwl_cons : forall (wl:dworklist) (w:dwork),
     (lc_dworklist wl) ->
     (lc_dwork w) ->
     (lc_dworklist (dwl_cons wl w))
 | lc_dwl_bind : forall (wl:dworklist) (x:exprvar) (A:expr),
     (lc_dworklist wl) ->
     (lc_expr A) ->
     (lc_dworklist (dwl_bind wl x A))
with lc_dwork : dwork -> Prop :=    (* defn lc_dwork *)
 | lc_dw_check : forall (ob:obindd) (e1 e2 A:expr),
     (lc_obindd ob) ->
     (lc_expr e1) ->
     (lc_expr e2) ->
     (lc_expr A) ->
     (lc_dwork (dw_check ob e1 e2 A))
 | lc_dw_infer : forall (e1 e2:expr) (wl:dworklist),
     (lc_expr e1) ->
     (lc_expr e2) ->
      ( forall x , lc_dworklist  ( open_dworklist_wrt_expr wl (e_var_f x) )  )  ->
     (lc_dwork (dw_infer e1 e2 wl))
 | lc_dw_infer_app : forall (A e1 e2:expr) (wl:dworklist),
     (lc_expr A) ->
     (lc_expr e1) ->
     (lc_expr e2) ->
      ( forall x , lc_dworklist  ( open_dworklist_wrt_expr wl (e_var_f x) )  )  ->
     (lc_dwork (dw_infer_app A e1 e2 wl))
 | lc_dw_reduce : forall (e:expr) (wl:dworklist),
     (lc_expr e) ->
      ( forall x , lc_dworklist  ( open_dworklist_wrt_expr wl (e_var_f x) )  )  ->
     (lc_dwork (dw_reduce e wl))
 | lc_dw_compact : forall (A B:expr),
     (lc_expr A) ->
     (lc_expr B) ->
     (lc_dwork (dw_compact A B)).
(** free variables *)
Fixpoint fv_expr (e_5:expr) : vars :=
  match e_5 with
  | (e_var_b nat) => {}
  | (e_var_f x) => {{x}}
  | (e_kind k) => {}
  | (e_num n) => {}
  | e_int => {}
  | (e_bot A) => (fv_expr A)
  | (e_app e1 e2) => (fv_expr e1) \u (fv_expr e2)
  | (e_abs A b) => (fv_expr A) \u (fv_body b)
  | (e_pi A B) => (fv_expr A) \u (fv_expr B)
  | (e_bind A b) => (fv_expr A) \u (fv_body b)
  | (e_all A B) => (fv_expr A) \u (fv_expr B)
  | (e_castup A e) => (fv_expr A) \u (fv_expr e)
  | (e_castdn e) => (fv_expr e)
end
with fv_body (b5:body) : vars :=
  match b5 with
  | (b_anno e A) => (fv_expr e) \u (fv_expr A)
end.

Definition fv_obindd (ob5:obindd) : vars :=
  match ob5 with
  | dob_none => {}
  | (dob_bind x A) => (fv_expr A)
end.

Fixpoint fv_dworklist (wl5:dworklist) : vars :=
  match wl5 with
  | dwl_nil => {}
  | (dwl_cons wl w) => (fv_dworklist wl) \u (fv_dwork w)
  | (dwl_bind wl x A) => (fv_dworklist wl) \u (fv_expr A)
end
with fv_dwork (w5:dwork) : vars :=
  match w5 with
  | (dw_check ob e1 e2 A) => (fv_obindd ob) \u (fv_expr e1) \u (fv_expr e2) \u (fv_expr A)
  | (dw_infer e1 e2 wl) => (fv_expr e1) \u (fv_expr e2) \u (fv_dworklist wl)
  | (dw_infer_app A e1 e2 wl) => (fv_expr A) \u (fv_expr e1) \u (fv_expr e2) \u (fv_dworklist wl)
  | (dw_reduce e wl) => (fv_expr e) \u (fv_dworklist wl)
  | (dw_compact A B) => (fv_expr A) \u (fv_expr B)
end.

Fixpoint fv_context (G5:context) : vars :=
  match G5 with
  | ctx_nil => {}
  | (ctx_cons G x A) => (fv_context G) \u (fv_expr A)
end.

(** substitutions *)
Fixpoint subst_expr (e_5:expr) (x5:exprvar) (e__6:expr) {struct e__6} : expr :=
  match e__6 with
  | (e_var_b nat) => e_var_b nat
  | (e_var_f x) => (if eq_var x x5 then e_5 else (e_var_f x))
  | (e_kind k) => e_kind k
  | (e_num n) => e_num n
  | e_int => e_int 
  | (e_bot A) => e_bot (subst_expr e_5 x5 A)
  | (e_app e1 e2) => e_app (subst_expr e_5 x5 e1) (subst_expr e_5 x5 e2)
  | (e_abs A b) => e_abs (subst_expr e_5 x5 A) (subst_body e_5 x5 b)
  | (e_pi A B) => e_pi (subst_expr e_5 x5 A) (subst_expr e_5 x5 B)
  | (e_bind A b) => e_bind (subst_expr e_5 x5 A) (subst_body e_5 x5 b)
  | (e_all A B) => e_all (subst_expr e_5 x5 A) (subst_expr e_5 x5 B)
  | (e_castup A e) => e_castup (subst_expr e_5 x5 A) (subst_expr e_5 x5 e)
  | (e_castdn e) => e_castdn (subst_expr e_5 x5 e)
end
with subst_body (e5:expr) (x5:exprvar) (b5:body) {struct b5} : body :=
  match b5 with
  | (b_anno e A) => b_anno (subst_expr e5 x5 e) (subst_expr e5 x5 A)
end.

Definition subst_obindd (e5:expr) (x5:exprvar) (ob5:obindd) : obindd :=
  match ob5 with
  | dob_none => dob_none 
  | (dob_bind x A) => dob_bind x (subst_expr e5 x5 A)
end.

Fixpoint subst_dworklist (e5:expr) (x5:exprvar) (wl5:dworklist) {struct wl5} : dworklist :=
  match wl5 with
  | dwl_nil => dwl_nil 
  | (dwl_cons wl w) => dwl_cons (subst_dworklist e5 x5 wl) (subst_dwork e5 x5 w)
  | (dwl_bind wl x A) => dwl_bind (subst_dworklist e5 x5 wl) x (subst_expr e5 x5 A)
end
with subst_dwork (e_5:expr) (x5:exprvar) (w5:dwork) {struct w5} : dwork :=
  match w5 with
  | (dw_check ob e1 e2 A) => dw_check (subst_obindd e_5 x5 ob) (subst_expr e_5 x5 e1) (subst_expr e_5 x5 e2) (subst_expr e_5 x5 A)
  | (dw_infer e1 e2 wl) => dw_infer (subst_expr e_5 x5 e1) (subst_expr e_5 x5 e2) (subst_dworklist e_5 x5 wl)
  | (dw_infer_app A e1 e2 wl) => dw_infer_app (subst_expr e_5 x5 A) (subst_expr e_5 x5 e1) (subst_expr e_5 x5 e2) (subst_dworklist e_5 x5 wl)
  | (dw_reduce e wl) => dw_reduce (subst_expr e_5 x5 e) (subst_dworklist e_5 x5 wl)
  | (dw_compact A B) => dw_compact (subst_expr e_5 x5 A) (subst_expr e_5 x5 B)
end.

Fixpoint subst_context (e5:expr) (x5:exprvar) (G5:context) {struct G5} : context :=
  match G5 with
  | ctx_nil => ctx_nil 
  | (ctx_cons G x A) => ctx_cons (subst_context e5 x5 G) x (subst_expr e5 x5 A)
end.


Fixpoint ctx_dom (G : context) : atoms :=
  match G with
  | ctx_nil => {}
  | ctx_cons G x A => add x (ctx_dom G)
  end
.



(** definitions *)

(* defns Monotype *)
Inductive mono_type : expr -> Prop :=    (* defn mono_type *)
 | mono_kind : forall (k:kind),
     mono_type (e_kind k)
 | mono_var : forall (x:exprvar),
     mono_type (e_var_f x)
 | mono_int : 
     mono_type e_int
 | mono_lit : forall (n:number),
     mono_type (e_num n)
 | mono_bot : forall (A:expr),
     lc_expr A ->
     mono_type (e_bot A)
 | mono_app : forall (e1 e2:expr),
     mono_type e1 ->
     mono_type e2 ->
     mono_type  ( (e_app e1 e2) ) 
 | mono_pi : forall (L:vars) (A B:expr),
     mono_type A ->
      ( forall x , x \notin  L  -> mono_type  ( open_expr_wrt_expr B (e_var_f x) )  )  ->
     mono_type (e_pi A B)
 | mono_lambda : forall (L:vars) (A e B:expr),
     lc_expr A ->
     lc_expr (e_abs A (b_anno e B)) ->
      ( forall x , x \notin  L  -> mono_type  ( open_expr_wrt_expr e (e_var_f x) )  )  ->
     mono_type (e_abs A (b_anno e B))
 | mono_bind : forall (L:vars) (A e B:expr),
     lc_expr A ->
     lc_expr (e_bind A (b_anno e B)) ->
      ( forall x , x \notin  L  -> mono_type  ( open_expr_wrt_expr e (e_var_f x) )  )  ->
     mono_type (e_bind A (b_anno e B))
 | mono_castup : forall (A e:expr),
     lc_expr A ->
     mono_type e ->
     mono_type (e_castup A e)
 | mono_castdn : forall (e:expr),
     mono_type e ->
     mono_type (e_castdn e).

(* defns Reduce *)
Inductive reduce : expr -> expr -> Prop :=    (* defn reduce *)
 | r_app : forall (e1 e3 e2:expr),
     lc_expr e3 ->
     reduce e1 e2 ->
     reduce (e_app e1 e3) (e_app e2 e3)
 | r_beta : forall (A e1 B e2:expr),
     lc_expr A ->
     lc_expr (e_abs A (b_anno e1 B)) ->
     lc_expr (e_abs A (b_anno e1 B)) ->
     lc_expr e2 ->
     reduce (e_app  ( (e_abs A (b_anno e1 B)) )  e2)  (open_expr_wrt_expr  e1   e2 ) 
 | r_inst : forall (A e1 B e2 e:expr),
     lc_expr A ->
     lc_expr (e_bind A (b_anno e1 B)) ->
     lc_expr (e_bind A (b_anno e1 B)) ->
     lc_expr e2 ->
     mono_type e ->
     reduce (e_app  ( (e_bind A (b_anno e1 B)) )  e2) (e_app  (  (open_expr_wrt_expr  e1   e )  )  e2)
 | r_castdn : forall (e1 e2:expr),
     reduce e1 e2 ->
     reduce (e_castdn e1) (e_castdn e2)
 | r_cast_inst : forall (A e1 B e:expr),
     lc_expr A ->
     lc_expr (e_bind A (b_anno e1 B)) ->
     lc_expr (e_bind A (b_anno e1 B)) ->
     mono_type e ->
     reduce (e_castdn  ( (e_bind A (b_anno e1 B)) ) ) (e_castdn  (  (open_expr_wrt_expr  e1   e )  ) )
 | r_cast_elim : forall (B e:expr),
     lc_expr B ->
     lc_expr e ->
     reduce (e_castdn  ( (e_castup B e) ) ) e.

(* defns InContext *)
Inductive in_ctx : exprvar -> expr -> context -> Prop :=    (* defn in_ctx *)
 | in_here : forall (x:exprvar) (A:expr) (G:context),
     lc_context G ->
     lc_expr A ->
     in_ctx x A (ctx_cons G x A)
 | in_there : forall (x:exprvar) (A:expr) (G:context) (y:exprvar) (B:expr),
     lc_expr B ->
     in_ctx x A G ->
     in_ctx x A (ctx_cons G y B).

(* defns UnifiedSubtyping *)
Inductive wf_context : context -> Prop :=    (* defn wf_context *)
 | wf_nil : 
     wf_context ctx_nil
 | wf_cons : forall (G:context) (x:exprvar) (A:expr) (k:kind),
     wf_context G ->
      ( x  `notin` ctx_dom  G )  ->
      (usub  G   A   A   (e_kind k) )  ->
     wf_context (ctx_cons G x A)
with usub : context -> expr -> expr -> expr -> Prop :=    (* defn usub *)
 | s_var : forall (G:context) (x:exprvar) (A:expr),
     wf_context G ->
     in_ctx x A G ->
     usub G (e_var_f x) (e_var_f x) A
 | s_lit : forall (G:context) (n:number),
     wf_context G ->
     usub G (e_num n) (e_num n) e_int
 | s_star : forall (G:context),
     wf_context G ->
     usub G (e_kind k_star) (e_kind k_star) (e_kind k_box)
 | s_int : forall (G:context),
     wf_context G ->
     usub G e_int e_int (e_kind k_star)
 | s_bot : forall (G:context) (A1 A2:expr) (k:kind),
     usub G A1 A2 (e_kind k) ->
     usub G A2 A1 (e_kind k) ->
     usub G (e_bot A1) (e_bot A2) A1
 | s_abs : forall (L:vars) (G:context) (A1 e1 B1 A2 e2 B2:expr) (k1 k2:kind),
     usub G A1 A2 (e_kind k1) ->
     usub G A2 A1 (e_kind k1) ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x A1)  ( open_expr_wrt_expr B1 (e_var_f x) )   ( open_expr_wrt_expr B2 (e_var_f x) )  (e_kind k2) )  ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x A1)  ( open_expr_wrt_expr B2 (e_var_f x) )   ( open_expr_wrt_expr B1 (e_var_f x) )  (e_kind k2) )  ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x A1)  ( open_expr_wrt_expr e1 (e_var_f x) )   ( open_expr_wrt_expr e2 (e_var_f x) )   ( open_expr_wrt_expr B1 (e_var_f x) )  )  ->
     usub G (e_abs A1 (b_anno e1 B1)) (e_abs A2 (b_anno e2 B2)) (e_pi A1 B1)
 | s_pi : forall (L:vars) (G:context) (A1 B1 A2 B2:expr) (k2 k1:kind),
      (usub  G   A1   A1   (e_kind k1) )  ->
     usub G A2 A1 (e_kind k1) ->
      ( forall x , x \notin  L  ->  (usub  (ctx_cons G x A1)    ( open_expr_wrt_expr B1 (e_var_f x) )     ( open_expr_wrt_expr B1 (e_var_f x) )    (e_kind k2) )  )  ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x A2)  ( open_expr_wrt_expr B1 (e_var_f x) )   ( open_expr_wrt_expr B2 (e_var_f x) )  (e_kind k2) )  ->
     usub G (e_pi A1 B1) (e_pi A2 B2) (e_kind k2)
 | s_app : forall (G:context) (e1 t1 e2 t2 B A:expr),
     mono_type t1 ->
     mono_type t2 ->
     usub G t1 t2 A ->
     usub G t2 t1 A ->
     usub G e1 e2 (e_pi A B) ->
     usub G (e_app e1 t1) (e_app e2 t2)  (open_expr_wrt_expr  B   t1 ) 
 | s_bind : forall (L:vars) (G:context) (A1 e1 B1 A2 e2 B2:expr) (k:kind),
     usub G A1 A2 (e_kind k) ->
     usub G A2 A1 (e_kind k) ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x A1)  ( open_expr_wrt_expr B1 (e_var_f x) )   ( open_expr_wrt_expr B2 (e_var_f x) )  (e_kind k_star) )  ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x A1)  ( open_expr_wrt_expr B2 (e_var_f x) )   ( open_expr_wrt_expr B1 (e_var_f x) )  (e_kind k_star) )  ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x A1)  ( open_expr_wrt_expr e1 (e_var_f x) )   ( open_expr_wrt_expr e2 (e_var_f x) )   ( open_expr_wrt_expr B1 (e_var_f x) )  )  ->
     usub G (e_bind A1 (b_anno e1 B1)) (e_bind A2 (b_anno e2 B2)) (e_all A1 B1)
 | s_castup : forall (G:context) (A1 e1 A2 e2:expr) (k:kind) (B:expr),
     usub G A1 A2 (e_kind k) ->
     usub G A2 A1 (e_kind k) ->
     reduce A1 B ->
     reduce A2 B ->
     usub G e1 e2 B ->
     usub G (e_castup A1 e1) (e_castup A2 e2) A1
 | s_castdn : forall (G:context) (e1 e2 B:expr) (k:kind) (A:expr),
      (usub  G   B   B   (e_kind k) )  ->
     reduce A B ->
     usub G e1 e2 A ->
     usub G (e_castdn e1) (e_castdn e2) B
 | s_forall_l : forall (L:vars) (G:context) (A B C t:expr) (k:kind),
     mono_type t ->
      (usub  G   A   A   (e_kind k) )  ->
      (usub  G   t   t   A )  ->
     usub G  (open_expr_wrt_expr  B   t )  C (e_kind k_star) ->
      ( forall x , x \notin  L  ->  (usub  (ctx_cons G x A)    ( open_expr_wrt_expr B (e_var_f x) )     ( open_expr_wrt_expr B (e_var_f x) )    (e_kind k_star) )  )  ->
     usub G (e_all A B) C (e_kind k_star)
 | s_forall_r : forall (L:vars) (G:context) (A B C:expr) (k:kind),
      (usub  G   B   B   (e_kind k) )  ->
      (usub  G   A   A   (e_kind k_star) )  ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x B) A  ( open_expr_wrt_expr C (e_var_f x) )  (e_kind k_star) )  ->
     usub G A (e_all B C) (e_kind k_star)
 | s_forall : forall (L:vars) (G:context) (A1 B A2 C:expr) (k:kind),
     usub G A1 A2 (e_kind k) ->
     usub G A2 A1 (e_kind k) ->
      ( forall x , x \notin  L  -> usub (ctx_cons G x A1)  ( open_expr_wrt_expr B (e_var_f x) )   ( open_expr_wrt_expr C (e_var_f x) )  (e_kind k_star) )  ->
     usub G (e_all A1 B) (e_all A2 C) (e_kind k_star)
 | s_sub : forall (G:context) (e1 e2 B A:expr) (k:kind),
     usub G e1 e2 A ->
     usub G A B (e_kind k) ->
     usub G e1 e2 B.

(* defns BidirectionalUnifiedSubtyping *)
Inductive bwf_context : context -> Prop :=    (* defn bwf_context *)
 | bwf_nil : 
     bwf_context ctx_nil
 | bwf_cons : forall (G:context) (x:exprvar) (A:expr) (k:kind),
     bwf_context G ->
      ( x  `notin` ctx_dom  G )  ->
      (busub  G   A   A   d_infer   (e_kind k) )  ->
     bwf_context (ctx_cons G x A)
with infer_app : context -> expr -> expr -> expr -> expr -> Prop :=    (* defn infer_app *)
 | iapp_pi : forall (L:vars) (G:context) (A B e1 e2:expr) (k:kind),
      ( forall x , x \notin  L  ->  (busub  (ctx_cons G x A)    ( open_expr_wrt_expr B (e_var_f x) )     ( open_expr_wrt_expr B (e_var_f x) )    d_infer   (e_kind k) )  )  ->
     busub G e1 e2 d_check A ->
     busub G e2 e1 d_check A ->
     infer_app G (e_pi A B) e1 e2  (open_expr_wrt_expr  B   e1 ) 
 | iapp_all : forall (L:vars) (G:context) (A B e1 e2 C t:expr),
     mono_type t ->
      (busub  G   t   t   d_check   A )  ->
      ( forall x , x \notin  L  ->  (usub  (ctx_cons G x A)    ( open_expr_wrt_expr B (e_var_f x) )     ( open_expr_wrt_expr B (e_var_f x) )    (e_kind k_star) )  )  ->
     infer_app G  (open_expr_wrt_expr  B   t )  e1 e2 C ->
     infer_app G (e_all A B) e1 e2 C
with greduce : context -> expr -> expr -> Prop :=    (* defn greduce *)
 | gr_reduce : forall (G:context) (e1 e2:expr),
     lc_context G ->
     reduce e1 e2 ->
     greduce G e1 e2
 | gr_all : forall (L:vars) (G:context) (A B C t:expr),
     mono_type t ->
      (busub  G   t   t   d_check   A )  ->
      ( forall x , x \notin  L  ->  (usub  (ctx_cons G x A)    ( open_expr_wrt_expr B (e_var_f x) )     ( open_expr_wrt_expr B (e_var_f x) )    (e_kind k_star) )  )  ->
     greduce G  (open_expr_wrt_expr  B   t )  C ->
     greduce G (e_all A B) C
with busub : context -> expr -> expr -> dir -> expr -> Prop :=    (* defn busub *)
 | bs_var : forall (G:context) (x:exprvar) (A:expr),
     bwf_context G ->
     in_ctx x A G ->
     busub G (e_var_f x) (e_var_f x) d_infer A
 | bs_lit : forall (G:context) (n:number),
     bwf_context G ->
     busub G (e_num n) (e_num n) d_infer e_int
 | bs_star_inf : forall (G:context),
     bwf_context G ->
     busub G (e_kind k_star) (e_kind k_star) d_infer (e_kind k_box)
 | bs_star_chk : forall (G:context),
     bwf_context G ->
     busub G (e_kind k_star) (e_kind k_star) d_check (e_kind k_box)
 | bs_int : forall (G:context),
     bwf_context G ->
     busub G e_int e_int d_infer (e_kind k_star)
 | bs_bot : forall (G:context) (A1 A2:expr) (k:kind),
     busub G A1 A2 d_infer (e_kind k) ->
     busub G A2 A1 d_infer (e_kind k) ->
     busub G (e_bot A1) (e_bot A2) d_infer A1
 | bs_abs : forall (L:vars) (G:context) (A1 e1 B1 A2 e2 B2:expr) (k1 k2:kind) (B:expr),
     busub G A1 A2 d_infer (e_kind k1) ->
     busub G A2 A1 d_infer (e_kind k1) ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A1)  ( open_expr_wrt_expr B1 (e_var_f x) )   ( open_expr_wrt_expr B2 (e_var_f x) )  d_infer (e_kind k2) )  ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A1)  ( open_expr_wrt_expr B2 (e_var_f x) )   ( open_expr_wrt_expr B1 (e_var_f x) )  d_infer (e_kind k2) )  ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A1)  ( open_expr_wrt_expr e1 (e_var_f x) )   ( open_expr_wrt_expr e2 (e_var_f x) )  d_check B )  ->
     busub G (e_abs A1 (b_anno e1 B1)) (e_abs A2 (b_anno e2 B2)) d_infer (e_pi A1 B1)
 | bs_pi_inf : forall (L:vars) (G:context) (A1 B1 A2 B2:expr) (k2 k1:kind),
      (busub  G   A1   A1   d_infer   (e_kind k1) )  ->
     busub G A2 A1 d_infer (e_kind k1) ->
      ( forall x , x \notin  L  ->  (busub  (ctx_cons G x A1)    ( open_expr_wrt_expr B1 (e_var_f x) )     ( open_expr_wrt_expr B1 (e_var_f x) )    d_infer   (e_kind k2) )  )  ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A2)  ( open_expr_wrt_expr B1 (e_var_f x) )   ( open_expr_wrt_expr B2 (e_var_f x) )  d_infer (e_kind k2) )  ->
     busub G (e_pi A1 B1) (e_pi A2 B2) d_infer (e_kind k2)
 | bs_pi_chk : forall (L:vars) (G:context) (A1 B1 A2 B2:expr) (k1:kind),
      (busub  G   A1   A1   d_infer   (e_kind k1) )  ->
     busub G A2 A1 d_infer (e_kind k1) ->
      ( forall x , x \notin  L  ->  (busub  (ctx_cons G x A1)    ( open_expr_wrt_expr B1 (e_var_f x) )     ( open_expr_wrt_expr B1 (e_var_f x) )    d_check   (e_kind k_box) )  )  ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A2)  ( open_expr_wrt_expr B1 (e_var_f x) )   ( open_expr_wrt_expr B2 (e_var_f x) )  d_check (e_kind k_box) )  ->
     busub G (e_pi A1 B1) (e_pi A2 B2) d_check (e_kind k_box)
 | bs_app : forall (G:context) (e1 t1 e2 t2 B A:expr),
     mono_type t1 ->
     mono_type t2 ->
     busub G e1 e2 d_infer A ->
     infer_app G A t1 t2 B ->
     busub G (e_app e1 t1) (e_app e2 t2) d_infer B
 | bs_bind : forall (L:vars) (G:context) (A1 e1 B1 A2 e2 B2:expr) (k:kind) (A B:expr),
     busub G A1 A2 d_infer (e_kind k) ->
     busub G A2 A1 d_infer (e_kind k) ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A1)  ( open_expr_wrt_expr B1 (e_var_f x) )   ( open_expr_wrt_expr B2 (e_var_f x) )  d_infer (e_kind k_star) )  ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A1)  ( open_expr_wrt_expr B2 (e_var_f x) )   ( open_expr_wrt_expr B1 (e_var_f x) )  d_infer (e_kind k_star) )  ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A)  ( open_expr_wrt_expr e1 (e_var_f x) )   ( open_expr_wrt_expr e2 (e_var_f x) )  d_check B )  ->
     busub G (e_bind A1 (b_anno e1 B1)) (e_bind A2 (b_anno e2 B2)) d_infer (e_all A1 B1)
 | bs_castup : forall (G:context) (A1 e1 A2 e2:expr) (k:kind) (B:expr),
     busub G A1 A2 d_infer (e_kind k) ->
     busub G A2 A1 d_infer (e_kind k) ->
     reduce A1 B ->
     reduce A2 B ->
     busub G e1 e2 d_check B ->
     busub G (e_castup A1 e1) (e_castup A2 e2) d_infer A1
 | bs_castdn : forall (G:context) (e1 e2 B:expr) (k:kind) (A:expr),
      (busub  G   B   B   d_infer   (e_kind k) )  ->
     greduce G A B ->
     busub G e1 e2 d_infer A ->
     busub G (e_castdn e1) (e_castdn e2) d_infer B
 | bs_forall_l : forall (L:vars) (G:context) (A B C t:expr) (k:kind),
     mono_type t ->
      (busub  G   A   A   d_infer   (e_kind k) )  ->
      (busub  G   t   t   d_check   A )  ->
     busub G  (open_expr_wrt_expr  B   t )  C d_infer (e_kind k_star) ->
      ( forall x , x \notin  L  ->  (busub  (ctx_cons G x A)    ( open_expr_wrt_expr B (e_var_f x) )     ( open_expr_wrt_expr B (e_var_f x) )    d_infer   (e_kind k_star) )  )  ->
     busub G (e_all A B) C d_infer (e_kind k_star)
 | bs_forall_r : forall (L:vars) (G:context) (A B C:expr) (k:kind),
      (busub  G   B   B   d_infer   (e_kind k) )  ->
      (busub  G   A   A   d_infer   (e_kind k_star) )  ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x B) A  ( open_expr_wrt_expr C (e_var_f x) )  d_infer (e_kind k_star) )  ->
     busub G A (e_all B C) d_infer (e_kind k_star)
 | bs_forall : forall (L:vars) (G:context) (A1 B A2 C:expr) (k:kind),
     busub G A1 A2 d_infer (e_kind k) ->
     busub G A2 A1 d_infer (e_kind k) ->
      ( forall x , x \notin  L  -> busub (ctx_cons G x A1)  ( open_expr_wrt_expr B (e_var_f x) )   ( open_expr_wrt_expr C (e_var_f x) )  d_infer (e_kind k_star) )  ->
     busub G (e_all A1 B) (e_all A2 C) d_infer (e_kind k_star)
 | bs_sub : forall (G:context) (e1 e2 B A:expr) (k:kind),
     busub G e1 e2 d_infer A ->
     busub G A B d_infer (e_kind k) ->
     busub G e1 e2 d_check B.


(** infrastructure *)
Hint Constructors mono_type reduce in_ctx wf_context usub bwf_context infer_app greduce busub lc_expr lc_body lc_obindd lc_context lc_dworklist lc_dwork : core.


