metavar aexprvar, x, y, z ::= {{ repr-locally-nameless }}
metavar number , n      ::= {{ coq nat }}
metavar exvar  , ex, ey ::= {{ coq var }}
metavar kindvar, kx, ky ::= {{ coq var }}

grammar

akind, k :: 'ak_' ::=
  | *   :: :: star
  | box :: :: box
  | kx  :: :: ex

abody, b :: 'ab_' ::=
  | e : A :: :: anno

aexpr, e, A, B, C, D, t, s :: 'ae_' ::=
  | x   :: :: var
  | k   :: :: kind
  | ex  :: :: ex
  | n   :: :: num
  | int :: :: int
  | bot : A :: :: bot
  | e1 e2   :: :: app
  | lambda x : A . b :: :: abs  (+ bind x in b +)
  | pi     x : A . B :: :: pi   (+ bind x in B +)
  | bind   x : A . b :: :: bind (+ bind x in b +)
  | forall x : A . B :: :: all  (+ bind x in B +)
  | castup [ A ] e :: :: castup
  | castdn e       :: :: castdn
  | e : A    :: :: anno
  | ( e )         :: S :: paren {{ coq ([[e]]) }}
  | [ e1 / x ] e2 :: M :: subst {{ coq (open_aexpr_wrt_aexpr [[x e2]] [[e1]]) }}

obind, ob :: 'ob_' ::=
  | none   :: :: none
  | x :! A :: :: bind

binding, bd :: 'b_' ::=
  |   x  :' A :: :: var
  | ^ ex : A :: :: ex
  | < kx >   :: :: kind

cont, c :: 'c_' ::=
  | Done :: :: done
  | _ . e1 & e2 => c :: :: app
  | _ --> c    :: :: reduce
  | _ <: A , c :: :: inst
  | _ <~: A    :: :: check

work, w :: 'w_' ::=
  | ob |= e1 <: e2 <= A :: :: check
  | e1 <: e2 => c       :: :: infer
  | A . e1 & e2 => c :: :: infer_app
  | e --> c :: :: reduce
  | A <~: B :: :: compact
  | c $ e   :: :: apply

worklist, wl :: 'wl_' ::=
  | nil     :: :: nil
  | wl |- w :: :: cons
  | wl , bd  :: :: bind

formula :: formula_ ::=
  | judgement :: :: judgement

substitutions
  single e x  :: subst
  single w  x :: subst
  single wl x :: subst
  single e ex  :: ex_subst
  single w  ex :: ex_subst
  single wl ex :: ex_subst
  single k kx  :: k_subst
  single e kx  :: k_subst
  single w  kx :: k_subst
  single wl kx :: k_subst

freevars
  aexpr x  :: fv
  aexpr ex :: fex
  akind kx :: fkv

defns
InWorklist :: '' ::=

defn
bd in wl :: :: in_wl :: 'iwl_'
by

------------- :: here
bd in wl , bd

bd in wl
------------- :: there_w
bd in wl |- w

bd in wl
------------- :: there_b
bd in wl, bd2

defns
InScope :: '' ::=

defn
wl [ bd1 ] [ bd2 ] :: :: in_scope :: 'ins_'
by

bd1 in wl
---------------- :: here
wl , bd2 [bd1][bd2]

wl [bd1][bd2]
---------------- :: there_w
wl |- w [bd1][bd2]

wl [bd1][bd2]
---------------- :: there_b
wl , bd [bd1][bd2]

defns
Monotype :: '' ::=

defn
mono A :: :: mono_atype :: 'amono_'
by

--------- :: kind
mono k

--------- :: ex
mono ex

--------- :: var
mono x

--------- :: int
mono int

--------- :: lit
mono n

------------- :: bot
mono bot : A

mono e1
mono e2
----------------- :: app
mono (e1 e2)

mono A
mono B
------------------ :: pi
mono pi x : A . B

mono e
--------------------------- :: lambda
mono lambda x : A . e : B

mono e
------------------------ :: bind
mono bind x : A . e : B

% mono e
% ---------------------- :: mu
% mono mu x . e

mono e
---------------- :: castup
mono castup [A] e

mono e
-------------- :: castdn
mono castdn e

mono e
-------------- :: anno
mono e : A

defns
StrongMonotype :: '' ::=

defn
smono A :: :: smono_atype :: 'asmono_'
by

--------- :: kind
smono k

--------- :: ex
smono ex

--------- :: var
smono x

--------- :: int
smono int

--------- :: lit
smono n

smono A
------------- :: bot
smono bot : A

smono e1
smono e2
----------------- :: app
smono (e1 e2)

smono A
smono B
------------------ :: pi
smono pi x : A . B

smono e
smono A
smono B
--------------------------- :: lambda
smono lambda x : A . e : B

smono e
smono A
smono B
------------------------ :: bind
smono bind x : A . e : B


smono e
smono A
---------------- :: castup
smono castup [A] e

smono e
-------------- :: castdn
smono castdn e

smono e
smono A
-------------- :: anno
smono e : A


defns
Reduce :: '' ::=

defn
e1 --> e2 :: :: areduce :: 'ar_'
by

e1 --> e2
---------------- :: app
e1 e3 --> e2 e3

------------------------------------------------------- :: beta
(lambda x : A . e1 : B) e2 --> [e2 / x] e1

mono e
--------------------------------------------------------- :: inst
(bind x : A . e1 : B) e2 --> ([e / x] e1) e2

% -------------------------------------- :: mu
% mu x : A. e --> [mu x : A. e / x] e

e1 --> e2
-------------------------------- :: castdn
castdn e1 --> castdn e2

mono e
-------------------------------------------------------- :: cast_inst
castdn (bind x : A . e1 : B) --> castdn ([e / x] e1)

-------------------------------- :: cast_elim
castdn (castup [A] e) --> e
